// ---------------------------------------------------------------------------------------------------------------------------------
//  _   _
// | | (_)
// | |_ _ _ __ ___   ___ _ __
// | __| | '_ ` _ \ / _ \ '__|
// | |_| | | | | | |  __/ |
//  \__|_|_| |_| |_|\___|_|
//
// Description:
//
//   High resolution timer
//
// Notes:
//
//   Best viewed with 8-character tabs and (at least) 132 columns
//
// History:
//
//   05/09/2001 by Paul Nettle: Original creation
//
// Originally released under a custom license.
// This historical re-release is provided under the MIT License.
// See the LICENSE file in the repo root for details.
//
// https://github.com/nettlep
//
// Copyright 2001, Fluid Studios, Inc., all rights reserved.
// ---------------------------------------------------------------------------------------------------------------------------------

#ifndef	_H_TIMER
#define _H_TIMER

// ---------------------------------------------------------------------------------------------------------------------------------
// Module setup (required includes, macros, etc.)
// ---------------------------------------------------------------------------------------------------------------------------------

#include <cmath>
#include <ctime>

// ---------------------------------------------------------------------------------------------------------------------------------

class	Timer
{
public:
	// Construction/Destruction

inline				Timer()
				{
					_highMultiplier = pow(2.0, 32.0);
				}

virtual				~Timer() {}

	// Implementation

inline		void 		readRDTSC(unsigned int *lo, unsigned int *hi) const
				{
					__asm
					{
						rdtsc
						mov	edi,hi
						mov	[edi],edx
						mov	edi,lo
						mov	[edi],eax
					}
				}

inline		void		calcFrequency()
				{
					// We'll use the performance counter as a basis for our calcs, so start their timer
					// and ours, side by side

					LARGE_INTEGER	perfTimerLead;
					unsigned int	leadLow, leadHigh;
					QueryPerformanceCounter(&perfTimerLead);
					readRDTSC(&leadLow, &leadHigh);
					
					// Do something to let a little bit of time go by (let's not wait a full second or anything,
					// just a little bit of time. :)

					unsigned int	t = clock() + 100;
					while((unsigned int) clock() < t);

					// Stop the timers simultaneously

					LARGE_INTEGER	perfTimerFall;
					unsigned int	fallLow, fallHigh;
					QueryPerformanceCounter(&perfTimerFall);
					readRDTSC(&fallLow, &fallHigh);
					
					// What is their frequency?

					LARGE_INTEGER	perfTimerFreq;
					QueryPerformanceFrequency(&perfTimerFreq);
					
					// Calculate how much time they say went by...

					double	hpFreq = (double) perfTimerFreq.HighPart * _highMultiplier + (double) perfTimerFreq.LowPart;
					double	hpDelt = deltaTicks(perfTimerLead.LowPart, perfTimerLead.HighPart, perfTimerFall.LowPart, perfTimerFall.HighPart);
					double	secondsElapsed = hpDelt / hpFreq;

					// Now, use that as a basis for syncronizing our timer					

					double	myDelt = deltaTicks(leadLow, leadHigh, fallLow, fallHigh);
					ticksPerSecond() = myDelt / secondsElapsed;
					ticksPerMillisecond() = ticksPerSecond() / 1000.0;
					ticksPerMicrosecond() = ticksPerSecond() / 1000000.0;
					ticksPerNanosecond() = ticksPerSecond() / 1000000000.0;
				}

inline		double		deltaTicks(const unsigned int sLo, const unsigned int sHi, const unsigned int eLo, const unsigned int eHi) const
				{
					unsigned int	dLo = eLo - sLo;
					unsigned int	dHi = eHi - sHi;
					if (eLo < sLo) dHi--;
					return static_cast<double>(dHi) * _highMultiplier + static_cast<double>(dLo);
				}

inline		void		startElapsedTickTimer()
				{
					readRDTSC(&_startTicksLo, &_startTicksHi);
				}

inline		double		readElapsedTickTimer() const
				{
					unsigned int	lo, hi;
					readRDTSC(&lo, &hi);
					return deltaTicks(_startTicksLo, _startTicksHi, lo, hi);
				}

	// Accessors

inline		double &	ticksPerSecond()		{return _ticksPerSecond;}
inline	const	double		ticksPerSecond() const		{return _ticksPerSecond;}
inline		double &	ticksPerMillisecond()		{return _ticksPerMillisecond;}
inline	const	double		ticksPerMillisecond() const	{return _ticksPerMillisecond;}
inline		double &	ticksPerMicrosecond()		{return _ticksPerMicrosecond;}
inline	const	double		ticksPerMicrosecond() const	{return _ticksPerMicrosecond;}
inline		double &	ticksPerNanosecond()		{return _ticksPerNanosecond;}
inline	const	double		ticksPerNanosecond() const	{return _ticksPerNanosecond;}

private:
	// Data members

		unsigned int	_startTicksLo;
		unsigned int	_startTicksHi;
		double		_ticksPerSecond;
		double		_ticksPerMillisecond;
		double		_ticksPerMicrosecond;
		double		_ticksPerNanosecond;
		double		_highMultiplier;
};

#endif // _H_TIMER
// ---------------------------------------------------------------------------------------------------------------------------------
// timer - End of file
// ---------------------------------------------------------------------------------------------------------------------------------
